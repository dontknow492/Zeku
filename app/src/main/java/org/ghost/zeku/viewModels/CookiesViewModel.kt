package org.ghost.zeku.viewModels

import android.annotation.SuppressLint
import android.app.Application
import android.content.ClipboardManager
import android.content.Context
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteDatabase.OPEN_READONLY
import android.webkit.CookieManager
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import org.ghost.zeku.BuildConfig
import org.ghost.zeku.core.utils.FileUtil
import org.ghost.zeku.database.models.CookieItem
import org.ghost.zeku.database.repository.CookieRepository
import timber.log.Timber
import java.io.File
import java.util.Date
import javax.inject.Inject


data class CookiesUiState(
    val cookies: List<CookieItem> = emptyList(),
    val selectedIds: Set<Long> = emptySet(),
    val error: String? = null
)

data class WebCookieItem(
    val domain: String = "",
    val name: String = "",
    val value: String = "",
    val includeSubdomains: Boolean = true,
    val path: String = "/",
    val secure: Boolean = true,
    val expiry: Long = 0L,
) {
    constructor(
        url: String,
        name: String,
        value: String
    ) : this(
        domain = url.replace(Regex("""http(s)?://(\w*(www|m|account|sso))?|/.*"""), ""),
        name = name,
        value = value
    )

    fun toNetscapeFormat(): String {
        val stringList = listOf(
            domain,
            includeSubdomains.toString().uppercase(),
            path,
            secure.toString().uppercase(),
            expiry.toString(),
            name,
            value
        )

        val builder = StringBuilder(stringList.first())

        for (s in stringList.subList(1, stringList.size)) {
            if (s.isNotEmpty()) {
                if (builder.isNotEmpty())
                    builder.append("\u0009")
                builder.append(s)
            }
        }
        return builder.toString()
    }
}

@HiltViewModel
class CookieViewModel @Inject constructor(
    private val application: Application,
    private val repository: CookieRepository,
) : ViewModel() {


    private val _selectedIds = MutableStateFlow<Set<Long>>(emptySet())
    private val _errors = MutableStateFlow<String?>(null)


    val uiState = combine(
        repository.items,
        _selectedIds,
        _errors
    ) { items, selectedIds, error ->
        CookiesUiState(
            cookies = items,
            selectedIds = selectedIds,
            error = error
        )
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = CookiesUiState()
    )

    val cookieHeader =
        "# Netscape HTTP Cookie File\n" +
                "# WebView Generated by the Zeku app\n" +
                "# This is a generated file! Do not edit."

    private val projection = arrayOf(
        CookieObject.HOST,
        CookieObject.EXPIRY,
        CookieObject.PATH,
        CookieObject.NAME,
        CookieObject.VALUE,
        CookieObject.SECURE
    )

    fun toggleSelection(template: CookieItem) {
        _selectedIds.update { currentIds ->
            if (template.id in currentIds) currentIds - template.id
            else currentIds + template.id
        }
    }

    fun clearSelection() {
        _selectedIds.value = emptySet()
    }

    fun selectAll() {
        _selectedIds.value = uiState.value.cookies.map { it.id }.toSet()
    }

    /** Selects all unselected items and deselects all selected items. */
    fun inverseSelection() {
        val allIds = uiState.value.cookies.map { it.id }.toSet()
        _selectedIds.update { currentSelectedIds ->
            allIds - currentSelectedIds // Uses set difference for a clean inversion
        }
    }


    fun getAll(): List<CookieItem> {
        return repository.getAll()
    }

    private fun getByURL(url: String): CookieItem? {
        return repository.getByURL(url)
    }

    private fun getByURLDescription(url: String, description: String): CookieItem? {
        return repository.getByURLDescription(url, description)
    }

    suspend fun insert(item: CookieItem): Long {
        val exists = getByURLDescription(item.url, item.description)
        if (exists != null) {
            exists.content = item.content
            repository.update(exists)
            return exists.id
        }

        return repository.insert(item)
    }

    fun delete(item: CookieItem) = viewModelScope.launch(Dispatchers.IO) {
        repository.delete(item)
        updateCookiesFile()
    }

    suspend fun changeCookieEnabledState(itemId: Long, isEnabled: Boolean) {
        repository.changeCookieEnabledState(itemId, isEnabled)
        updateCookiesFile()
    }

    fun deleteAll() = viewModelScope.launch(Dispatchers.IO) {
        repository.deleteAll()
    }

    fun update(item: CookieItem) = viewModelScope.launch(Dispatchers.IO) {
        repository.update(item)
    }

    object CookieObject {
        const val NAME = "name"
        const val VALUE = "value"
        const val SECURE = "is_secure"
        const val EXPIRY = "expires_utc"
        const val HOST = "host_key"
        const val PATH = "path"
    }

    @SuppressLint("SdCardPath")
    fun getCookiesFromDB(url: String): Result<String> = kotlin.runCatching {
        CookieManager.getInstance().run {
            if (!hasCookies()) throw Exception("There is no cookies in the database!")
            flush()
        }
        val dbPath = File("/data/data/${BuildConfig.APPLICATION_ID}/").walkTopDown()
            .find { it.name == "Cookies" }
            ?: throw Exception("Cookies File not found!")

        val db = SQLiteDatabase.openDatabase(
            dbPath.absolutePath, null, OPEN_READONLY
        )


        val cookieList = mutableListOf<WebCookieItem>()
        db.query(
            "cookies", projection, null, null, null, null, null
        ).run {
            while (moveToNext()) {
                val expiry = getLong(getColumnIndexOrThrow(CookieObject.EXPIRY))
                val name = getString(getColumnIndexOrThrow(CookieObject.NAME))
                val value = getString(getColumnIndexOrThrow(CookieObject.VALUE))
                val path = getString(getColumnIndexOrThrow(CookieObject.PATH))
                val secure = getLong(getColumnIndexOrThrow(CookieObject.SECURE)) == 1L
                val hostKey = getString(getColumnIndexOrThrow(CookieObject.HOST))


                val host = if (hostKey[0] != '.') ".$hostKey" else hostKey
                cookieList.add(
                    WebCookieItem(
                        domain = host,
                        name = name,
                        value = value,
                        path = path,
                        secure = secure,
                        expiry = expiry
                    )
                )
            }
            close()
        }
        db.close()

        "# $url\n" +
                "# Generated by Zeku\n" +
                cookieList.fold(StringBuilder("")) { acc, cookie ->
                    acc.append(cookie.toNetscapeFormat()).append("\n")
                }.toString()
    }

    fun updateCookiesFile() = viewModelScope.launch(Dispatchers.IO) {
        val cookies = repository.getAllEnabled()
        val cookieTXT = StringBuilder(cookieHeader)
        FileUtil.getCookieFile(application, true) { c ->
            val cookieFile = File(c)
            if (cookies.isEmpty()) cookieFile.apply { writeText("") }
            cookies.forEach {
                it.content.lines().forEach { line ->
                    if (!cookieTXT.contains(line)) cookieTXT.append(it.content)
                }
            }
            cookieFile.apply { writeText(cookieTXT.toString()) }
        }

    }

    suspend fun importFromClipboard() {
        try {
            val clipboard: ClipboardManager =
                application.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
            var clip = clipboard.primaryClip!!.getItemAt(0).text
            Timber.e(clip.toString())

            if (clip.startsWith("# Netscape HTTP Cookie File")) {
                clip = clip.removePrefix(cookieHeader)
                val cookie = CookieItem(
                    0,
                    "",
                    clip.toString(),
                    "Cookie Import at [${Date()}]",
                    true
                )
                insert(cookie)
                updateCookiesFile()
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

}